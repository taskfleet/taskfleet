// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: instances.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createInstance = `-- name: CreateInstance :exec
INSERT INTO instances (
    id,
    provider,
    provider_id,
    zone,
    owner,
    instance_type,
    is_spot,
    cpu_count_requested,
    memory_mib_requested,
    memory_mib_reserved,
    gpu_count_requested,
    boot_image,
    created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
`

type CreateInstanceParams struct {
	ID                 uuid.UUID
	Provider           Provider
	ProviderID         string
	Zone               string
	Owner              InstanceOwner
	InstanceType       string
	IsSpot             bool
	CpuCountRequested  int32
	MemoryMibRequested int32
	MemoryMibReserved  int32
	GpuCountRequested  int32
	BootImage          string
	CreatedAt          time.Time
}

func (q *Queries) CreateInstance(ctx context.Context, arg CreateInstanceParams) error {
	_, err := q.db.Exec(ctx, createInstance,
		arg.ID,
		arg.Provider,
		arg.ProviderID,
		arg.Zone,
		arg.Owner,
		arg.InstanceType,
		arg.IsSpot,
		arg.CpuCountRequested,
		arg.MemoryMibRequested,
		arg.MemoryMibReserved,
		arg.GpuCountRequested,
		arg.BootImage,
		arg.CreatedAt,
	)
	return err
}

const getInstance = `-- name: GetInstance :one
SELECT id, provider, provider_id, zone, owner, instance_type, is_spot, cpu_count_requested, memory_mib_requested, memory_mib_reserved, gpu_count_requested, boot_image, hostname, created_at, booted_at, started_at, deleted_at, is_deletion_triaged
FROM instances
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetInstance(ctx context.Context, id uuid.UUID) (Instance, error) {
	row := q.db.QueryRow(ctx, getInstance, id)
	var i Instance
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderID,
		&i.Zone,
		&i.Owner,
		&i.InstanceType,
		&i.IsSpot,
		&i.CpuCountRequested,
		&i.MemoryMibRequested,
		&i.MemoryMibReserved,
		&i.GpuCountRequested,
		&i.BootImage,
		&i.Hostname,
		&i.CreatedAt,
		&i.BootedAt,
		&i.StartedAt,
		&i.DeletedAt,
		&i.IsDeletionTriaged,
	)
	return i, err
}

const listPastBootedInstances = `-- name: ListPastBootedInstances :many
SELECT id, provider, provider_id, zone, owner, instance_type, is_spot, cpu_count_requested, memory_mib_requested, memory_mib_reserved, gpu_count_requested, boot_image, hostname, created_at, booted_at, started_at, deleted_at, is_deletion_triaged
FROM instances
WHERE deleted_at IS NULL
    AND booted_at IS NOT NULL
    AND started_at IS NULL
    AND booted_at < NOW() - $1::INTERVAL
`

func (q *Queries) ListPastBootedInstances(ctx context.Context, minAge pgtype.Interval) ([]Instance, error) {
	rows, err := q.db.Query(ctx, listPastBootedInstances, minAge)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Instance{}
	for rows.Next() {
		var i Instance
		if err := rows.Scan(
			&i.ID,
			&i.Provider,
			&i.ProviderID,
			&i.Zone,
			&i.Owner,
			&i.InstanceType,
			&i.IsSpot,
			&i.CpuCountRequested,
			&i.MemoryMibRequested,
			&i.MemoryMibReserved,
			&i.GpuCountRequested,
			&i.BootImage,
			&i.Hostname,
			&i.CreatedAt,
			&i.BootedAt,
			&i.StartedAt,
			&i.DeletedAt,
			&i.IsDeletionTriaged,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPastDeletedUntriagedInstances = `-- name: ListPastDeletedUntriagedInstances :many
SELECT id, provider, provider_id, zone, owner, instance_type, is_spot, cpu_count_requested, memory_mib_requested, memory_mib_reserved, gpu_count_requested, boot_image, hostname, created_at, booted_at, started_at, deleted_at, is_deletion_triaged
FROM instances
WHERE deleted_at IS NOT NULL
    AND deleted_at < NOW() - $1::INTERVAL
    AND is_deletion_triaged = FALSE
`

func (q *Queries) ListPastDeletedUntriagedInstances(ctx context.Context, minAge pgtype.Interval) ([]Instance, error) {
	rows, err := q.db.Query(ctx, listPastDeletedUntriagedInstances, minAge)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Instance{}
	for rows.Next() {
		var i Instance
		if err := rows.Scan(
			&i.ID,
			&i.Provider,
			&i.ProviderID,
			&i.Zone,
			&i.Owner,
			&i.InstanceType,
			&i.IsSpot,
			&i.CpuCountRequested,
			&i.MemoryMibRequested,
			&i.MemoryMibReserved,
			&i.GpuCountRequested,
			&i.BootImage,
			&i.Hostname,
			&i.CreatedAt,
			&i.BootedAt,
			&i.StartedAt,
			&i.DeletedAt,
			&i.IsDeletionTriaged,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPastRequestedInstances = `-- name: ListPastRequestedInstances :many
SELECT id, provider, provider_id, zone, owner, instance_type, is_spot, cpu_count_requested, memory_mib_requested, memory_mib_reserved, gpu_count_requested, boot_image, hostname, created_at, booted_at, started_at, deleted_at, is_deletion_triaged
FROM instances
WHERE deleted_at IS NULL
    AND booted_at IS NULL
    AND created_at < NOW() - $1::INTERVAL
`

func (q *Queries) ListPastRequestedInstances(ctx context.Context, minAge pgtype.Interval) ([]Instance, error) {
	rows, err := q.db.Query(ctx, listPastRequestedInstances, minAge)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Instance{}
	for rows.Next() {
		var i Instance
		if err := rows.Scan(
			&i.ID,
			&i.Provider,
			&i.ProviderID,
			&i.Zone,
			&i.Owner,
			&i.InstanceType,
			&i.IsSpot,
			&i.CpuCountRequested,
			&i.MemoryMibRequested,
			&i.MemoryMibReserved,
			&i.GpuCountRequested,
			&i.BootImage,
			&i.Hostname,
			&i.CreatedAt,
			&i.BootedAt,
			&i.StartedAt,
			&i.DeletedAt,
			&i.IsDeletionTriaged,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRunningInstances = `-- name: ListRunningInstances :many
SELECT id, provider, provider_id, zone, owner, instance_type, is_spot, cpu_count_requested, memory_mib_requested, memory_mib_reserved, gpu_count_requested, boot_image, hostname, created_at, booted_at, started_at, deleted_at, is_deletion_triaged
FROM instances
WHERE deleted_at IS NULL
    AND started_at IS NOT NULL
    AND owner = $1
`

func (q *Queries) ListRunningInstances(ctx context.Context, owner InstanceOwner) ([]Instance, error) {
	rows, err := q.db.Query(ctx, listRunningInstances, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Instance{}
	for rows.Next() {
		var i Instance
		if err := rows.Scan(
			&i.ID,
			&i.Provider,
			&i.ProviderID,
			&i.Zone,
			&i.Owner,
			&i.InstanceType,
			&i.IsSpot,
			&i.CpuCountRequested,
			&i.MemoryMibRequested,
			&i.MemoryMibReserved,
			&i.GpuCountRequested,
			&i.BootImage,
			&i.Hostname,
			&i.CreatedAt,
			&i.BootedAt,
			&i.StartedAt,
			&i.DeletedAt,
			&i.IsDeletionTriaged,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setInstanceBooting = `-- name: SetInstanceBooting :exec
UPDATE instances
SET
    booted_at = $2::TIMESTAMPTZ,
    hostname = $3::TEXT
WHERE id = $1
`

type SetInstanceBootingParams struct {
	ID       uuid.UUID
	BootedAt time.Time
	Hostname string
}

func (q *Queries) SetInstanceBooting(ctx context.Context, arg SetInstanceBootingParams) error {
	_, err := q.db.Exec(ctx, setInstanceBooting, arg.ID, arg.BootedAt, arg.Hostname)
	return err
}

const setInstanceDeleted = `-- name: SetInstanceDeleted :exec
UPDATE instances
SET deleted_at = $2::TIMESTAMPTZ
WHERE id = $1
`

type SetInstanceDeletedParams struct {
	ID        uuid.UUID
	DeletedAt time.Time
}

func (q *Queries) SetInstanceDeleted(ctx context.Context, arg SetInstanceDeletedParams) error {
	_, err := q.db.Exec(ctx, setInstanceDeleted, arg.ID, arg.DeletedAt)
	return err
}

const setInstanceDeletionTriaged = `-- name: SetInstanceDeletionTriaged :exec
UPDATE instances
SET is_deletion_triaged = TRUE
WHERE id = $1
`

func (q *Queries) SetInstanceDeletionTriaged(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, setInstanceDeletionTriaged, id)
	return err
}

const setInstanceRunning = `-- name: SetInstanceRunning :exec
UPDATE instances
SET started_at = $2::TIMESTAMPTZ
WHERE id = $1
`

type SetInstanceRunningParams struct {
	ID        uuid.UUID
	StartedAt time.Time
}

func (q *Queries) SetInstanceRunning(ctx context.Context, arg SetInstanceRunningParams) error {
	_, err := q.db.Exec(ctx, setInstanceRunning, arg.ID, arg.StartedAt)
	return err
}
